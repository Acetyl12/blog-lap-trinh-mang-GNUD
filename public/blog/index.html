<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Blogs | Blog Lập Trình Mạng</title>
<meta name="keywords" content="">
<meta name="description" content="Blogs - Blog Lập Trình Mạng">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a482bf00fa5c046040ef7973ad5fdf5657890cacb596c93f1382f664ca542074.css" integrity="sha256-pIK/APpcBGBA73lzrV/fVleJDKy1lsk/E4L2ZMpUIHQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/blog/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Blog Lập Trình Mạng (Alt + H)">Blog Lập Trình Mạng</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog/" title="Blog">
                    <span class="active">Blog</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a></div>
  <h1>
    Blogs
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Concurrency trong ứng dụng mạng Java
    </h2>
  </header>
  <div class="entry-content">
    <p>3 mô hình phổ biến:
Thread-per-connection (dễ nhất, tốn tài nguyên), ThreadPool &#43; Queue (cân bằng hơn), NIO/Reactive (hiệu năng cao). Gợi ý: dùng ExecutorService, giới hạn pool, đo độ trễ/tải, và quản lý backpressure (hàng đợi). Với IO-bound, ưu tiên NIO/Reactor/Vert.x/Spring WebFlux.
</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to Concurrency trong ứng dụng mạng Java" href="http://localhost:1313/blog/java-concurrency-cho-ung-dung-mang/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Fetch vs Axios: gọi API hiệu quả
    </h2>
  </header>
  <div class="entry-content">
    <p>fetch là native, axios tiện alias &amp; interceptor. Best-practices:
Tạo HTTP client dùng chung (baseURL, timeout, headers). Interceptor xử lý token &amp; lỗi 401/403. Chuẩn hoá response (success/data/error), có retry/backoff cho lỗi mạng tạm thời. </p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to Fetch vs Axios: gọi API hiệu quả" href="http://localhost:1313/blog/js-fetch-axios-xu-ly-api/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java 11&#43;: HttpClient hiện đại (sync/async)
    </h2>
  </header>
  <div class="entry-content">
    <p>java.net.http.HttpClient (Java 11&#43;) đơn giản hoá gọi REST:
Tạo HttpClient, HttpRequest, sau đó send() (sync) hoặc sendAsync() (CompletableFuture). Dễ set timeout, redirect, header; parse JSON với Jackson/Gson. Ví dụ: GET/POST, retry (tự viết), log request/response, và best-practices (timeout, circuit-breaker bên ngoài như Resilience4j).
</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to Java 11&#43;: HttpClient hiện đại (sync/async)" href="http://localhost:1313/blog/java-http-client-modern-11-plus/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java cơ bản: Giới thiệu Lập trình Mạng &amp; Socket
    </h2>
  </header>
  <div class="entry-content">
    <p>Bài viết mở đầu chuỗi Java Network: tổng quan TCP/UDP, địa chỉ IP/Port, và mô hình Client/Server.
Socket là điểm đầu cuối của kết nối mạng. Với Java, gói java.net cung cấp Socket, ServerSocket (TCP) và DatagramSocket (UDP).
Khi nào dùng TCP? Khi cần tin cậy, có thứ tự. Khi nào dùng UDP? Khi cần tốc độ, chấp nhận mất mát (streaming, game).
Mẹo học: phác thảo luồng dữ liệu từ client → server và log mọi trạng thái để dễ debug.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to Java cơ bản: Giới thiệu Lập trình Mạng & Socket" href="http://localhost:1313/blog/java-co-ban-gioi-thieu-mang-socket/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java NIO: Selector &amp; Channel cho kết nối đồng thời
    </h2>
  </header>
  <div class="entry-content">
    <p>java.nio hỗ trợ non-blocking I/O với Selector &#43; Channel, xử lý nhiều socket trên 1 thread.
Lợi ích: tiết kiệm tài nguyên hơn so với mỗi kết nối một thread.
Ý tưởng chính:
ServerSocketChannel non-blocking &#43; Selector theo dõi events OP_ACCEPT/OP_READ/OP_WRITE. Bộ đệm ByteBuffer tái sử dụng để giảm GC. Thiết kế state machine cho từng connection (đọc header → đọc body → xử lý → ghi). </p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to Java NIO: Selector & Channel cho kết nối đồng thời" href="http://localhost:1313/blog/java-nio-selector-va-channel/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java Socket TCP: Server/Client cơ bản
    </h2>
  </header>
  <div class="entry-content">
    <p>Ví dụ tối giản:
Server: mở ServerSocket, chấp nhận Socket, đọc/ghi qua InputStream/OutputStream. Client: tạo Socket(host, port), gửi chuỗi, nhận phản hồi. Các bước an toàn:
Dùng try-with-resources để đóng tài nguyên. Quy ước message protocol (ví dụ: chuỗi JSON kết thúc bằng \n). Thử nghiệm bằng telnet/nc để kiểm tra server. </p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to Java Socket TCP: Server/Client cơ bản" href="http://localhost:1313/blog/java-socket-tcp-server-client-co-ban/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">JavaScript Event Loop &amp; Network I/O
    </h2>
  </header>
  <div class="entry-content">
    <p>Event Loop là trái tim của JS runtime. Network I/O diễn ra bất đồng bộ:
Task Queue (macro), Microtask Queue (Promise callbacks). Thực hành: tránh block main thread, dùng async/await và Promise.allSettled khi cần. Debug tip: thêm timestamp và request-id khi log để truy lần.
</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to JavaScript Event Loop & Network I/O" href="http://localhost:1313/blog/js-event-loop-network-io/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Node.js: net(dành cho TCP) &amp; dgram(cho UDP)
    </h2>
  </header>
  <div class="entry-content">
    <p>Node.js cung cấp:
net để tạo TCP server/client, dgram cho UDP socket. Mẹo:
Thiết kế protocol rõ ràng (delimiters, length-prefix). Dùng Buffer đúng cách, chống split/merge packet. Thêm health-check &amp; graceful shutdown (SIGINT/SIGTERM). </p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to Node.js: net(dành cho TCP) & dgram(cho UDP)" href="http://localhost:1313/blog/nodejs-net-module-tcp-udp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">WebSocket cơ bản: realtime trong JS/Node
    </h2>
  </header>
  <div class="entry-content">
    <p>WebSocket cho kết nối 2 chiều thời gian thực (chat, dashboard).
Frontend: new WebSocket(url); Backend: ws (Node) hoặc Socket.IO (có fallback &amp; rooms).
Lưu ý: xác thực (JWT qua query/header), ping/pong, auto-reconnect, phân kênh (rooms), và hạn mức message size.
</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-09 00:00:00 +0000 UTC'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer>
  <a class="entry-link" aria-label="post link to WebSocket cơ bản: realtime trong JS/Node" href="http://localhost:1313/blog/js-websocket-realtime-co-ban/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Blog Lập Trình Mạng</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
